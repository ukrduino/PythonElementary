NEED TO KNOW
1. The differences between list, tuple, and set.

    list (список) - упорядоченная изменяемая коллекция объектов произвольных
    типов.

    tuple (кортеж) - упорядоченная НЕизменяемая коллекция объектов произвольных
    типов. Кортеж использует меньше памяти, чем список. Кортеж вместо
    квадратных скобок использует круглые. Кортеж не допускает изменений, в
    него нельзя добавить новый элемент, хотя он может содержать объекты,
    которые можно изменить, например списки.

    set — неотсортированная коллекция уникальных элементов. Сеты поддерживают
    итерацию, добавление и удаление объектов и т.д. Индексация и срезы в
    сетах не поддерживаются.


2. What is a dictionary?
    Dictionary(словарь) это – изменяемая структура данных, предназначенная
    для хранения элементов вида ключ: значение.
    Ключем и значением может быть любой тип данных.

3. Which types are mutable, and which are not?

    Неизменяемые типы
    Strings, Unicode, Tuples, Frozen sets

    Изменяемые типы
    Lists, Byte Arrays, Sets, Dictionaries

4. What does “tuple unpacking” mean?

    tuple unpacking - это присваивание элементов кортежа переменным по порядку:
    d = (1, 2, 3)
    a, b, c = d

5. What is list comprehension and dictionary comprehension?
    list comprehension and dictionary comprehension (генераторы списков и
    словарей) - это удобные(укороченные)
    способы создания словарей и списков например:
    >>> a = [ i*i for i in range(1,10)]
    [1, 4, 9, 16, 25, 36, 49, 64, 81]
    >>> a = { i:i*i for i in range(1,10)}
    {1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

6. What’s the result of the expression [1, 2, 3][0 or 2] and why?
    Результат выражения - 3
    1. Сначала выполняется булевое выражение [0 or 2] которое дает - 2 т.к.
    0 приводится к False
    2. Далее из списка [1, 2, 3] берется элемент с индексом 2 т.е. это 3

7. What does a generator return? What are the pros and cons of using
    generators?

    При вызове генератор возвращает одно вычисленное значение при повторном
    вызове второе и т.д

    generator = (x*x for x in range(3)) тут создается объект генератор, а не
    весь список вычисленнных значений

    for i in generator : # при обращении генератор возвращает только одно
        print(i)         # вычисленное знечение за раз, когда он пройдет все
                         # циклы внутри себя он вернет exceptions.StopIteration
                         # второй раз пройти по генератору и получить значения
                         # не получится, его нужно повторно создавать

    pros:
    проводит вычисления только в момент обращения не занимая память всеми
    результатами вычислений.
    может содержать внутри бесконечные алгоритмы без риска т.к. следующая
    итерация делается только по команде из вне.

    cons:
    может использоваться только один раз

    Генератор можно создать используя в функции оператор yield

    def generator() :
       mylist = range(3)
       for i in mylist :
           yield i*i

    my_generator = generator() # создали объект генератора

    my_generator.next() # получаем поочередно вычисленные значения
    my_generator.next() # получаем поочередно вычисленные значения
    my_generator.next() # получаем поочередно вычисленные значения
    my_generator.next() # получаем исключение StopIteration т.к. после
    прохода по всем значениям генератор возвращает исключение StopIteration


8. How are exceptions handled? How to raise an exception?

    Исключения обрабатываются с помощью  конструкции try except finally
    try:
        x = int(input("Введите, пожалуйста, целое число: "))

    except ValueError:
        print "Вы ошиблись. Попробуйте еще раз…"

    finally:
        pass

    сначала выполняется код в блоке try, если там не возникло исключительной
    ситуации, то блок except пропускается и выполняется блок finally

    если в блоке try произошла исключительная ситуация  описанная в блоке
    except (например ValueError), то исполняется блок except,
    а потом блок finally.

    T.e. блок finally выполняется в любом случае, если нужно выполнить
    финальный блок только при отсутствии исключения, то finally можно
    заменить на else (try - except - else)


    Можно самому создать свое исключение унаследовав его от класса Exception
    и вызвать с помощью команды raise в нужном участке кода